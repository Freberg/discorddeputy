package com.freberg.discorddeputy.command;import com.freberg.discorddeputy.BotApplication;import com.freberg.discorddeputy.api.ApiApplicatiionApi;import com.freberg.discorddeputy.invoker.ApiCallback;import com.freberg.discorddeputy.invoker.ApiClient;import com.freberg.discorddeputy.invoker.ApiException;import com.freberg.discorddeputy.model.DiscordNotification;import discord4j.core.object.entity.Message;import joptsimple.OptionParser;import joptsimple.OptionSet;import lombok.extern.slf4j.Slf4j;import org.springframework.beans.factory.annotation.Value;import org.springframework.stereotype.Component;import reactor.core.publisher.Flux;import java.util.List;import java.util.Map;import java.util.Optional;@Slf4j@Componentpublic class ListOffersCommand implements Command {    private static final String LIST_OFFERS_COMMAND = "!offers";    private static final String ARG_END_POINT = "e";    private static final String ARG_TYPE = "t";    private static final String END_POINT_EPIC_GAMES = "epicGames";    private static final String OPTION_CURRENT = "current";    private static final String OPTION_UPCOMING = "upcoming";    private static final OptionParser PARSER = new OptionParser(ARG_END_POINT + "::" + ARG_TYPE + "::");    private final ApiApplicatiionApi api;    private ListOffersCommand(@Value("${discorddeputy.api.url}") String apiUrl) {        var apiClient = new ApiClient();        apiClient.setBasePath(apiUrl);        this.api = new ApiApplicatiionApi(apiClient);    }    @Override    public String getCommand() {        return LIST_OFFERS_COMMAND;    }    @Override    public String getDescription() {        return "list offers from different end points\n";    }    @Override    public String getHelp() {        return "[-e] {epicGames} (Required)\n" +                "[-t] {current, upcoming} (Default is current)";    }    @Override    public void accept(Message message) {        var options = PARSER.parse(message.getContent().split(" "));        var endPoint = getArgument(options, ARG_END_POINT);        var type = getArgument(options, ARG_TYPE);        if (endPoint == null) {            sendHelpReponse(message);            return;        }        switch (endPoint) {            case END_POINT_EPIC_GAMES -> {                try {                    if (OPTION_CURRENT.equals(type)) {                        api.getCurrentOffersAsync(new DiscordDeputyApiCallBack(message));                    } else {                        api.getUpcomingOffersAsync(new DiscordDeputyApiCallBack(message));                    }                } catch (ApiException e) {                    log.error("API call failed with status code {}", e.getCode(), e);                }            }            default -> sendHelpReponse(message);        }    }    private String getArgument(OptionSet options, String arg) {        return Optional.of(arg)                .filter(options::hasArgument)                .map(options::valueOf)                .map(String.class::cast)                .orElse(null);    }    private record DiscordDeputyApiCallBack(Message message) implements ApiCallback<List<DiscordNotification>> {        @Override        public void onFailure(ApiException e, int statusCode, Map<String, List<String>> responseHeaders) {            // Do nothing        }        @Override        public void onSuccess(List<DiscordNotification> result, int statusCode, Map<String, List<String>> responseHeaders) {            Flux.fromIterable(result)                    .flatMap(notification -> message.getChannel().flatMap(channel ->                            channel.createMessage(BotApplication.toEmbedCreateSpec(notification))))                    .subscribe();        }        @Override        public void onUploadProgress(long bytesWritten, long contentLength, boolean done) {            // Do nothing        }        @Override        public void onDownloadProgress(long bytesRead, long contentLength, boolean done) {            // Do nothing        }    }}
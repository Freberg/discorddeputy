package com.freberg.discorddeputy.command;import java.util.List;import java.util.Map;import java.util.Optional;import com.freberg.discorddeputy.api.EpicGamesOfferClient;import com.freberg.discorddeputy.api.EpicGamesOfferControllerApi;import com.freberg.discorddeputy.invoker.ApiCallback;import com.freberg.discorddeputy.invoker.ApiException;import com.freberg.discorddeputy.model.Offer;import com.freberg.discorddeputy.reponse.DiscordOfferResponseUtil;import discord4j.core.object.entity.Message;import joptsimple.OptionParser;import joptsimple.OptionSet;import lombok.RequiredArgsConstructor;import lombok.extern.slf4j.Slf4j;import reactor.core.publisher.Flux;@Slf4j@RequiredArgsConstructorpublic class ListOffersCommand implements Command {    private static final String LIST_OFFERS_COMMAND = "!offers";    private static final String ARG_END_POINT = "e";    private static final String ARG_TYPE = "t";    private static final String END_POINT_EPIC_GAMES = "epicGames";    private static final String OPTION_CURRENT = "current";    private static final String OPTION_UPCOMING = "upcoming";    private static final OptionParser PARSER = new OptionParser(ARG_END_POINT + "::" + ARG_TYPE + "::");    private final EpicGamesOfferClient epicGamesOfferClient;    private final EpicGamesOfferControllerApi offerApi = new EpicGamesOfferControllerApi();    @Override    public String getCommand() {        return LIST_OFFERS_COMMAND;    }    @Override    public String getDescription() {        return "list offers from different end points\n";    }    @Override    public String getHelp() {        return "[-e] {epicGames} (Required)\n" +               "[-t] {current, upcoming} (Default is current)";    }    @Override    public void accept(Message message) {        OptionSet options = PARSER.parse(message.getContent().split(" "));        String endPoint = getArgument(options, ARG_END_POINT);        String type = getArgument(options, ARG_TYPE);        if (endPoint == null) {            sendHelpReponse(message);            return;        }        switch (endPoint) {            case END_POINT_EPIC_GAMES:                try {                    if (OPTION_CURRENT.equals(type)) {                        offerApi.getCurrentOffersAsync(new OfferApiCallBack(message));                    } else {                        offerApi.getUpcomingOffersAsync(new OfferApiCallBack(message));                    }                } catch (ApiException e) {                    log.error("API call failed with status code {}", e.getCode(), e);                }                break;            default:                sendHelpReponse(message);                break;        }    }    private String getArgument(OptionSet options, String arg) {        return Optional.of(arg)                       .filter(options::hasArgument)                       .map(options::valueOf)                       .map(String.class::cast)                       .orElse(null);    }    @RequiredArgsConstructor    private static class OfferApiCallBack implements ApiCallback<List<Offer>> {        private final Message message;        @Override        public void onFailure(ApiException e, int statusCode, Map<String, List<String>> responseHeaders) {            // Do nothing        }        @Override        public void onSuccess(List<Offer> result, int statusCode, Map<String, List<String>> responseHeaders) {            Flux.fromIterable(result)                  .flatMap(offer -> message.getChannel().flatMap(channel -> channel.createEmbed(spec ->                          DiscordOfferResponseUtil.createOfferMessage(offer, spec, true))))                  .subscribe();        }        @Override        public void onUploadProgress(long bytesWritten, long contentLength, boolean done) {            // Do nothing        }        @Override        public void onDownloadProgress(long bytesRead, long contentLength, boolean done) {            // Do nothing        }    }}